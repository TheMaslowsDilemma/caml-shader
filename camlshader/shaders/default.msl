#include <metal_stdlib>
using namespace metal;

/*** These shapes are taken from Inigo Quilez articles ***/
float sdBoxFrame(float3 p, float3 b, float e )
{
    p = abs(p) - b;
    float3 q = abs(p + e) - e;
    return min(min(
        length(max(float3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),
        length(max(float3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),
        length(max(float3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0)
    );
}

float sdSphere(float3 p, float s) {
    return length(p) - s;
}

float sdBox(float3 p, float3 b) {
    float3 q = abs(p) - b;
    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}

float sdTriPrism(float3 p, float2 h )
{
  float3 q = abs(p);
  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);
}

float smin( float a, float b, float k )
{
    k *= 2.0;
    float x = b - a;
    return 0.5 * (a + b - sqrt( x * x + k * k));
}

float smoothstep( float x )
{
  return x * x * (2.0 - x * x);
}

float hash(float2 p) {
    return fract(dot(p + 0.4609375000, p * 0.4609375000)) ;
}

float sdf(float3 p, float2 id) {
    float randomness = hash(id);
    float randomness2 = hash(id * 1.7031250000);
    float height = 3.0 + 8.0 * randomness;
    float width = 2.0 + randomness * 3.0;
    float ground = -p.y;

    // Building Base //
    float3 building_pos = float3(randomness2 * 10, 0, randomness * 10);
    float3 building_dims = float3(width, height, width);

    // Roof //
    float3 roof_pos = building_pos + float3(0, height * 1.25, 0); 
    float roof_dist = sdTriPrism(p * float3(1, -1, 1) - roof_pos, float2(width, width));
    
    // Chimney //
    float3 chimney_pos = roof_pos + float3(width * 0.5, 0, width);
    float chimney_dist = sdBox(p - chimney_pos, float3(0.4, 3, 0.4));
    float roof_and_chimney = min(roof_dist, chimney_dist);

    // Building Trim /
    float building_trim_thicc = 0.25;

    // Building Distance Combinations //
    float building_dist = min(
        sdBox(p - building_pos, building_dims),
        sdBoxFrame(p - building_pos, building_dims + building_trim_thicc, building_trim_thicc)
    );
    building_dist = smin(building_dist, roof_and_chimney, 0.05);

    return min(ground, building_dist);
}

/**
    Taken from Fantastic Article:
    https://iquilezles.org/articles/sdfrepetition/

    slightly modified to be for 3d
    basically you just have to check 
    the sdf and your your neighbors,
    keeping track of the 

    p: position of point;
    size: repetition dimension of SDF
    spacing: distance btw repetitions
**/
float map(float3 p)
{

    float2 size = float2(10, 10);
    float spacing = 25;

    int i, j;
    float2 id = round(p.xz / spacing);
    float2 o = sign(p.xz - spacing * id);
    float d = 1e20;
    for (j = 0; j < 2; ++j)
    for (i = 0; i < 2; ++i)
    {
        float2 rid = id + float2(i, j) * o;
        rid = clamp(rid, -(size - 1.0) * 0.5, (size - 1.0) * 0.5);
        float3 r = p;
        r.xz = p.xz - spacing * rid;

        // ----- "sdf" ----- //
        d = min(d, sdf(r, rid));
    }
    return d;
}
    // https://iquilezles.org/articles/normalsSDF/

    // NOTE: there are a few versions of the "calcNormal"
    // all are described in the article by Inigo Quilezles
    // 1. hq: uses 6 calls to 
    // 2. mid: uses 4 calls
    // 3. low: uses 3 calls and assumes fp = 0
    // 4. Tetrahedron Technique found below

float3 calcNormal(float3 p) {
    float h = 0.001;
    float2 k = float2(1, -1);
    return normalize(
        k.xyy * map(p + k.xyy * h) +
        k.yyx * map(p + k.yyx * h) +
        k.yxy * map(p + k.yxy * h) +
        k.xxx * map(p + k.xxx * h)
    );
}

float softshadow(float3 ro, float3 rd, float mint, float maxt, float k )
{
    float res = 1.0;
    float t = mint;
    for( int i=0; i < 256 && t<maxt; i++ )
    {
        float h = map(ro + rd * t);
        if( h < 0.001 )
            return 0.0;
        res = min( res, k * h / t );
        t += h;
    }
    return res;
}

float shadow(float3 ro, float3 rd, float mint, float maxt )
{
    float t = mint;
    for (int i = 0; i < 256 && t < maxt; i++)
    {
        float h = map(ro + rd * t);
        if (h < 0.001)
            return 0.0;
        t += h;
    }
    return 1.0;
}


kernel void default_shader(
    device    uchar4 *output  [[buffer(0)]],
    constant  uint2 &dims     [[buffer(1)]],
    constant  float *scene    [[buffer(2)]], /* TODO: structure this better */
    uint2 gid [[thread_position_in_grid]])
{
    if (gid.x >= dims.x || gid.y >= dims.y) return;
    uint index = gid.y * dims.x + gid.x;

    float2 uv = (float2(gid) / float2(dims)) * 2.0 - 1.0;
    uv.x *= float(dims.x) / float(dims.y);

    //if ( fract(gid.x * hash(float2(gid)) + gid.y) > 0.75) { output[index] = output[index + 1]; return; }

    float3 forward = normalize(float3(scene[3], scene[4], scene[5]));
    float3 worldUp = float3(0.0, 1.0, 0.0);

    float3 right = normalize(cross(forward, worldUp));
    float3 up    = cross(right, forward);

    float3 rd = normalize(
        forward
      + uv.x * right
      + uv.y * up
    );

    //*** Camera Direction and Origin ***//
    float3 ro = float3(scene[0], scene[1], scene[2]);

    float t = 0.0;
    float maxt = 200;
    float mint = 0.001;
    bool hit = false;
    float3 p;

    for (int i = 0; i < 100; i++) {
        p = ro + rd * t;
        float d = map(p);
        if (d < mint) {
            hit = true;
            break;
        }
        t += d;
        if (t > maxt) break;
    }

    float3 color = float3(0.1, 0.2, 0.5);
    if (hit) {
        float3 normal = calcNormal(p);
        float3 light_pos = float3(scene[6], scene[7], scene[8]);
        float3 light_dir = normalize(light_pos - p);

        float dist_to_light = length(light_pos - p);
        float diff = max(dot(normal, light_dir), 0.0);
        float shade = softshadow(p + normal * 0.01, light_dir, 0.01, dist_to_light, 32);

        color = float3(0.05) + float3(0.7) * diff + 0.25 * shade;

    }

    output[index] = uchar4(uchar3(clamp(color, 0.0, 1.0) * 255), 255);
}