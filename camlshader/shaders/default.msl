#include <metal_stdlib>
using namespace metal;

/*** These shapes are taken from Inigo Quilez articles ***/
float sdBoxFrame(float3 p, float3 b, float e )
{
    p = abs(p) - b;
    float3 q = abs(p + e) - e;
    return min(min(
        length(max(float3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),
        length(max(float3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),
        length(max(float3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0)
    );
}

float sdSphere(float3 p, float s) {
    return length(p) - s;
}

float sdBox(float3 p, float3 b) {
    float3 q = abs(p) - b;
    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}

float smin(float a, float b, float k)
{
    k *= log(2.0);
    float x = b-a;
    return a + x / ( 1.0 - exp2(x/k));
}

float smoothstep( float x )
{
  return 0.5 - 0.5 * cos(1.7031250000 * x);
}

float hash(float2 p) {
    return fract(dot(p,p * 0.4609375000)) ;
}

float2 f2mod(float2 p, float2 k) {
    return p - k * round(p / k + 0.5);
}

float sdf(float3 p, float2 id) {
    float ground = -p.y;
    // float2 spacing = float2(20, 20);
    // float2 id = round(p.xz / spacing);
    float3 base_pos = p;
    //base_pos.xz = base_pos.xz - spacing * id;
    
    float randomness = hash(id);
    float height = 3.0 + 8 * randomness;
    float width = 2 + randomness * 3;

    // Building Base Square //
    float3 building_pos = float3(0, 0, 0);
    float3 building_dims = float3(width, height, width);


    // Building Trim //
    float building_trim_thicc = 0.25;

    // Windows //
    // float window_height = 0.5 + randomness * 0.5;
    // float window_width = 0.5 + randomness * 0.5;
    // float3 p_rel_window = base_pos;
    // p_mod_window.xy = fmod(base_pos.xy + win
    // float windows = 

    float building_dist = min(
        sdBox(base_pos - building_pos, building_dims),
        sdBoxFrame(base_pos - building_pos, building_dims + building_trim_thicc, building_trim_thicc)
    );


    // Door Cut Out Base Square //
    float3 door_pos = float3(0, 0, width);
    float door_dist = sdBox(base_pos - door_pos, float3(width/5, 2.5, width/5));

    return min(ground, max(building_dist, -door_dist));
}

/**
    Taken from Fantastic Article:
    https://iquilezles.org/articles/sdfrepetition/

    slightly modified to be for 3d
    basically you just have to check 
    the sdf and your your neighbors,
    keeping track of the 

    p: position of point;
    size: repetition dimension of SDF
    spacing: distance btw repetitions
**/
float map(float3 p)
{

    float2 size = float2(10, 100);
    float spacing = 25;

    int i, j;
    float2 id = round(p.xz / spacing);
    float2 o = sign(p.xz - spacing * id);
    float d = 1e20;
    for (j = 0; j < 2; ++j)
    for (i = 0; i < 2; ++i)
    {
        float2 rid = id + float2(i, j) * o;
        rid = clamp(rid, -(size - 1.0) * 0.5, (size - 1.0) * 0.5);
        float3 r = p;
        r.xz = p.xz - spacing * rid;

        // ----- "sdf" ----- //
        d = min(d, sdf(r, rid));
    }
    return d;
}
    // https://iquilezles.org/articles/normalsSDF/

    // NOTE: there are a few versions of the "calcNormal"
    // all are described in the article by Inigo Quilezles
    // 1. hq: uses 6 calls to 
    // 2. mid: uses 4 calls
    // 3. low: uses 3 calls and assumes fp = 0
    // 4. Tetrahedron Technique found below

float3 calcNormal(float3 p) {
    float h = 0.001;
    float2 k = float2(1, -1);
    return normalize(
        k.xyy * map(p + k.xyy * h) +
        k.yyx * map(p + k.yyx * h) +
        k.yxy * map(p + k.yxy * h) +
        k.xxx * map(p + k.xxx * h)
    );
}

float softshadow(float3 ro, float3 rd, float mint, float maxt, float k )
{
    float res = 1.0;
    float t = mint;
    for( int i=0; i < 256 && t<maxt; i++ )
    {
        float h = map(ro + rd * t);
        if( h < 0.001 )
            return 0.0;
        res = min( res, k * h / t );
        t += h;
    }
    return res;
}

float shadow(float3 ro, float3 rd, float mint, float maxt )
{
    float t = mint;
    for (int i = 0; i < 256 && t < maxt; i++)
    {
        float h = map(ro + rd * t);
        if (h < 0.001)
            return 0.0;
        t += h;
    }
    return 1.0;
}


kernel void default_shader(
    device    uchar4 *output  [[buffer(0)]],
    constant  uint2 &dims     [[buffer(1)]],
    constant  float *scene    [[buffer(2)]], /* TODO: structure this better */
    uint2 gid [[thread_position_in_grid]])
{
    if (gid.x >= dims.x || gid.y >= dims.y) return;

    float2 uv = (float2(gid) / float2(dims)) * 2.0 - 1.0;
    uv.x *= float(dims.x) / float(dims.y);

    float3 forward = normalize(float3(scene[3], scene[4], scene[5]));
    float3 worldUp = float3(0.0, 1.0, 0.0);

    float3 right = normalize(cross(forward, worldUp));
    float3 up    = cross(right, forward);

    float3 rd = normalize(
        forward
      + uv.x * right
      + uv.y * up
    );

    //*** Camera Direction and Origin ***//
    float3 ro = float3(scene[0], scene[1], scene[2]);

    float t = 0.0;
    float maxt = 200;
    float mint = 0.001;
    bool hit = false;
    float3 p;

    for (int i = 0; i < 100; i++) {
        p = ro + rd * t;
        float d = map(p);
        if (d < mint) {
            hit = true;
            break;
        }
        t += d;
        if (t > maxt) break;
    }

    float3 color = float3(0.1, 0.2, 0.5);
    if (hit) {
        float3 normal = calcNormal(p);
        float3 light_pos = float3(scene[6], scene[7], scene[8]);

        float3 light_dir = normalize(light_pos - p);
        float dist_to_light = length(light_pos - p);

        float diff = max(dot(normal, light_dir), 0.0);

        float shade = shadow(p + normal * 0.01, light_dir, 0.01, dist_to_light);//, 32);

        color = float3(0.05) + float3(0.7) * diff + 0.25 * shade;

    }

    uint index = gid.y * dims.x + gid.x;
    output[index] = uchar4(uchar3(clamp(color, 0.0, 1.0) * 255), 255);
}